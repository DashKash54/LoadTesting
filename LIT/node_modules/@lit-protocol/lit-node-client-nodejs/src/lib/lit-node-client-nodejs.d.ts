import { ILitResource, ISessionCapabilityObject, LitAccessControlConditionResource, LitResourceAbilityRequest } from '@lit-protocol/auth-helpers';
import { LitCore } from '@lit-protocol/core';
import type { AuthCallbackParams, AuthSig, ClaimKeyResponse, ClaimProcessor, ClaimRequest, CustomNetwork, DecryptRequest, DecryptResponse, EncryptRequest, EncryptResponse, ExecuteJsResponse, GetSessionSigsProps, GetSignedTokenRequest, GetWalletSigProps, LitClientSessionManager, LitNodeClientConfig, NodeBlsSigningShare, NodeCommandResponse, RejectedNodePromises, SessionKeyPair, SessionSigsMap, SignSessionKeyProp, SignSessionKeyResponse, SuccessNodePromises, ILitNodeClient, GetPkpSessionSigs, CapacityCreditsReq, CapacityCreditsRes, JsonExecutionSdkParamsTargetNode, JsonExecutionSdkParams, JsonPkpSignSdkParams, SigResponse, EncryptSdkParams, GetLitActionSessionSigs, GetSignSessionKeySharesProp } from '@lit-protocol/types';
export declare class LitNodeClientNodeJs extends LitCore implements LitClientSessionManager, ILitNodeClient {
    #private;
    defaultAuthCallback?: (authSigParams: AuthCallbackParams) => Promise<AuthSig>;
    constructor(args: LitNodeClientConfig | CustomNetwork);
    createCapacityDelegationAuthSig: (params: CapacityCreditsReq) => Promise<CapacityCreditsRes>;
    /**
     *
     * we need to send jwt params iat (issued at) and exp (expiration) because the nodes may have different wall clock times, the nodes will verify that these params are withing a grace period
     *
     */
    getJWTParams: () => {
        iat: number;
        exp: number;
    };
    /**
     * Try to get the session key in the local storage,
     * if not, generates one.
     * @return { SessionKeyPair } session key pair
     */
    getSessionKey: () => SessionKeyPair;
    /**
     * Check if a given object is of type SessionKeyPair.
     *
     * @param obj - The object to check.
     * @returns True if the object is of type SessionKeyPair.
     */
    isSessionKeyPair(obj: any): obj is SessionKeyPair;
    /**
     * Generates wildcard capability for each of the LIT resources
     * specified.
     * @param litResources is an array of LIT resources
     * @param addAllCapabilities is a boolean that specifies whether to add all capabilities for each resource
     */
    static generateSessionCapabilityObjectWithWildcards(litResources: ILitResource[], addAllCapabilities?: boolean, rateLimitAuthSig?: AuthSig): Promise<ISessionCapabilityObject>;
    generateSessionCapabilityObjectWithWildcards(litResources: ILitResource[]): Promise<ISessionCapabilityObject>;
    /**
     *
     * Get expiration for session default time is 1 day / 24 hours
     *
     */
    static getExpiration: () => string;
    getExpiration: () => string;
    /**
     *
     * Get the signature from local storage, if not, generates one
     *
     */
    getWalletSig: ({ authNeededCallback, chain, sessionCapabilityObject, switchChain, expiration, sessionKeyUri, nonce, resourceAbilityRequests, litActionCode, litActionIpfsId, jsParams, sessionKey, }: GetWalletSigProps) => Promise<AuthSig>;
    /**
     *
     * Check if a session key needs to be resigned. These are the scenarios where a session key needs to be resigned:
     * 1. The authSig.sig does not verify successfully against the authSig.signedMessage
     * 2. The authSig.signedMessage.uri does not match the sessionKeyUri
     * 3. The authSig.signedMessage does not contain at least one session capability object
     *
     */
    checkNeedToResignSessionKey: ({ authSig, sessionKeyUri, resourceAbilityRequests, }: {
        authSig: AuthSig;
        sessionKeyUri: any;
        resourceAbilityRequests: LitResourceAbilityRequest[];
    }) => Promise<boolean>;
    /**
     *
     * Combine Shares from network public key set and signature shares
     *
     * @param { NodeBlsSigningShare } signatureShares
     *
     * @returns { string } final JWT (convert the sig to base64 and append to the jwt)
     *
     */
    combineSharesAndGetJWT: (signatureShares: NodeBlsSigningShare[], requestId?: string) => string;
    getIpfsId: ({ dataToHash, sessionSigs, }: {
        dataToHash: string;
        sessionSigs: SessionSigsMap;
        debug?: boolean | undefined;
    }) => Promise<any>;
    /**
     * Run lit action on a single deterministicly selected node. It's important that the nodes use the same deterministic selection algorithm.
     *
     * Lit Action: dataToHash -> IPFS CID
     * QmUjX8MW6StQ7NKNdaS6g4RMkvN5hcgtKmEi8Mca6oX4t3
     *
     * @param { ExecuteJsProps } params
     *
     * @returns { Promise<SuccessNodePromises<T> | RejectedNodePromises> }
     *
     */
    runOnTargetedNodes: (params: JsonExecutionSdkParamsTargetNode) => Promise<SuccessNodePromises<NodeCommandResponse> | RejectedNodePromises>;
    /**
     *
     * Get signatures from signed data
     *
     * @param { Array<any> } signedData
     *
     * @returns { any }
     *
     */
    getSessionSignatures: (signedData: any[]) => any;
    /**
     *
     * Get a single signature
     *
     * @param { Array<any> } shareData from all node promises
     *
     * @returns { string } signature
     *
     */
    getSignature: (shareData: any[], requestId: string) => Promise<any>;
    /**
     *
     * Execute JS on the nodes and combine and return any resulting signatures
     *
     * @param { JsonExecutionSdkParams } params
     *
     * @returns { ExecuteJsResponse }
     *
     */
    executeJs: (params: JsonExecutionSdkParams) => Promise<ExecuteJsResponse>;
    /**
     * Generates a promise by sending a command to the Lit node
     *
     * @param url - The URL to send the command to.
     * @param params - The parameters to include in the command.
     * @param requestId - The ID of the request.
     * @returns A promise that resolves with the response from the server.
     */
    generatePromise: (url: string, params: any, requestId: string) => Promise<NodeCommandResponse>;
    /**
     * Use PKP to sign
     *
     * @param { JsonPkpSignSdkParams } params
     * @param params.toSign - The data to sign
     * @param params.pubKey - The public key to sign with
     * @param params.sessionSigs - The session signatures to use
     * @param params.authMethods - (optional) The auth methods to use
     */
    pkpSign: (params: JsonPkpSignSdkParams) => Promise<SigResponse>;
    /**
     *
     * Request a signed JWT from the LIT network. Before calling this function, you must know the access control conditions for the item you wish to gain authorization for.
     *
     * @param { GetSignedTokenRequest } params
     *
     * @returns { Promise<string> } final JWT
     *
     */
    getSignedToken: (params: GetSignedTokenRequest) => Promise<string>;
    /**
     *
     * Encrypt data using the LIT network public key.
     *
     * @param { EncryptSdkParams } params
     * @param params.dataToEncrypt - The data to encrypt
     * @param params.accessControlConditions - (optional) The access control conditions for the data
     * @param params.evmContractConditions - (optional) The EVM contract conditions for the data
     * @param params.solRpcConditions - (optional) The Solidity RPC conditions for the data
     * @param params.unifiedAccessControlConditions - (optional) The unified access control conditions for the data
     *
     * @return { Promise<EncryptResponse> } The encrypted ciphertext and the hash of the data
     *
     * @throws { Error } if the LIT node client is not ready
     * @throws { Error } if the subnetPubKey is null
     */
    encrypt: (params: EncryptSdkParams) => Promise<EncryptResponse>;
    /**
     *
     * Decrypt ciphertext with the LIT network.
     *
     */
    decrypt: (params: DecryptRequest) => Promise<DecryptResponse>;
    getLitResourceForEncryption: (params: EncryptRequest) => Promise<LitAccessControlConditionResource>;
    /** ============================== SESSION ============================== */
    /**
     * Sign a session public key using a PKP, which generates an authSig.
     * @returns {Object} An object containing the resulting signature.
     */
    signSessionKey: (params: SignSessionKeyProp) => Promise<SignSessionKeyResponse>;
    getSignSessionKeyShares: (url: string, params: GetSignSessionKeySharesProp, requestId: string) => Promise<any>;
    /**
     * Get session signatures for a set of resources
     *
     * High level, how this works:
     * 1. Generate or retrieve session key
     * 2. Generate or retrieve the wallet signature of the session key
     * 3. Sign the specific resources with the session key
     *
     * Note: When generating session signatures for different PKPs or auth methods,
     * be sure to call disconnectWeb3 to clear auth signatures stored in local storage
     *
     * @param { GetSessionSigsProps } params
     *
     * @example
     *
     * ```ts
     * import { LitPKPResource, LitActionResource } from "@lit-protocol/auth-helpers";
  import { LitAbility } from "@lit-protocol/types";
  import { logWithRequestId } from '../../../misc/src/lib/misc';
  
  const resourceAbilityRequests = [
      {
        resource: new LitPKPResource("*"),
        ability: LitAbility.PKPSigning,
      },
      {
        resource: new LitActionResource("*"),
        ability: LitAbility.LitActionExecution,
      },
    ];
     * ```
     */
    getSessionSigs: (params: GetSessionSigsProps) => Promise<SessionSigsMap>;
    /**
     * Retrieves the PKP sessionSigs.
     *
     * @param params - The parameters for retrieving the PKP sessionSigs.
     * @returns A promise that resolves to the PKP sessionSigs.
     * @throws An error if any of the required parameters are missing or if `litActionCode` and `ipfsId` exist at the same time.
     */
    getPkpSessionSigs: (params: GetPkpSessionSigs) => Promise<SessionSigsMap>;
    /**
     * Retrieves session signatures specifically for Lit Actions.
     * Unlike `getPkpSessionSigs`, this function requires either `litActionCode` or `litActionIpfsId`, and `jsParams` must be provided.
     *
     * @param params - The parameters required for retrieving the session signatures.
     * @returns A promise that resolves with the session signatures.
     */
    getLitActionSessionSigs: (params: GetLitActionSessionSigs) => Promise<SessionSigsMap>;
    /**
     *
     * Get Session Key URI eg. lit:session:0x1234
     *
     * @param publicKey is the public key of the session key
     * @returns { string } the session key uri
     */
    getSessionKeyUri: (publicKey: string) => string;
    /**
     * Authenticates an Auth Method for claiming a Programmable Key Pair (PKP).
     * A {@link MintCallback} can be defined for custom on chain interactions
     * by default the callback will forward to a relay server for minting on chain.
     * @param {ClaimKeyRequest} params an Auth Method and {@link MintCallback}
     * @returns {Promise<ClaimKeyResponse>}
     */
    claimKeyId(params: ClaimRequest<ClaimProcessor>): Promise<ClaimKeyResponse>;
}
